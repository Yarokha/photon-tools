#!/usr/bin/python
# vim: set fileencoding=utf-8

# fcs-tools - Tools for FCS data analysis
#
# Copyright Â© 2010 Ben Gamari
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see http://www.gnu.org/licenses/ .
#
# Author: Ben Gamari <bgamari@physics.umass.edu>
#

import sys 
from collections import namedtuple

import scipy, numpy
from scipy.optimize import leastsq
from numpy import min, max, linspace, mean, exp, power, sqrt
import suffix_parse

"""
fcs-fit: Multiple-curve non-linear regression framework for fitting of FCS
correlation functions

This is a framework for "global" analysis of FCS correlation functions.
"""

models = {}
def register_model(*names):
        def reg(cls):
                if not issubclass(cls, Model):
                        raise Exception("Registering model that doesn't inherit from model")
                for n in names:
                        models[n] = cls
                return cls
        return reg

class Parameter(object):
        def __init__(self, name, description, def_value=None, def_scope=None):
                self.name = name
                self.description = description
                self.def_value = def_value
                self.def_scope = def_scope

class Parameters(dict):
        def __init__(self, model, curves):
                from copy import copy
                assert(len(curves) > 0)
                self.curves = curves
                
                for p in model.params:
                        a = copy(p)
                        a.scope = p.def_scope
                        a.value = p.def_value
                        self[p.name] = a

        def validate(self):
                """ Needs to be called before pack or unpack are used """
                self._fitted = []
                self._fixed = []
                for p in self.values():
                        if p.scope == 'fitted':
                                self._fitted.append(p.name)
                        elif p.scope == 'fixed':
                                self._fixed.append(p.name)
                        else:
                                raise RuntimeError('Invalid scope')

        def _unpack(self, packed):
                """ Unpack parameters from vector from leastsq """
                n = len(self.curves)
                i = 0
                for k in self._fitted:
                        if isinstance(self[k], list):
                                self[k].value = packed[i:i+n]
                                i += n
                        else:
                                self[k].value = packed[i]
                                i += 1

        def _pack(self):
                """ Pack fitted parameters into vector for leastsq """
                packed = []
                for k in self._fitted:
                        if isinstance(self[k].value, list):
                                packed.extend(self[k].value)
                        else:
                                packed.append(self[k].value)
                return numpy.array(packed)

        def _curve_params(self, curve):
                """ Generate full parameters dict from fixed and fitted parameters """
                params = {}
                for k in self:
                        v = self[k].value
                        params[k] = v[i] if isinstance(v, list) else v
                return params

class Model(object):
        """
        Represents a fitting model for a multi-curve non-linear regression
 
        A model has parameters, which can be either fixed or chosen for
        optimization. In the latter case, the parameter can be taken as
        determined by the fit, or fixed per-curve. In either case, the parameter
        can be set independently for each curve, or homogenous across all
        curves. Each parameter is set to be fixed/fitted and (in)homogenous at
        model creation.

        To implement a new fit function, one must inherit from the Model class,
        providing a class member 'params' list giving the parameters supported by
        the model and their default scope. The fit function itself is given by
        the compute_G function.
        """

        # Override this in subclasses
        params = []

        @classmethod
        def param(cls, name):
                for p in cls.params:
                        if p.name == name: return p
                
        def compute_G(self, params, x):
                """ Compute the value of the fit function with the given
                    parameters on the given domain """
                pass

def _compute_error(p, curves, params, model):
        err = []
        params._unpack(p)
        for i,c in enumerate(curves):
                cparams = params._curve_params(i)
                G = model.compute_G(cparams, c['lag'])
                err.extend(c['G'] - G)
                #err.extend((c['G'] - G) / c['err'])

        return numpy.array(err)

def fit(curves, model, params):
        """ Run the regression. Returns a new Model object with optimized
            parameters. One can then evaluate the optimized fit
            functions using this new object's G function. """
        from copy import deepcopy
        params = deepcopy(params)
        params.validate()
        p0 = params._pack()
        print p0
        res = scipy.optimize.leastsq(_compute_error, p0, args=(curves, params, model), full_output=True)
        p, cov_x, infodict, mesg, ier = res
        params._unpack(p)

        err = _compute_error(p, curves, params, model)
        chi_squared = sum(err**2)
        return (params, chi_squared)

@register_model('3d_diff')
class DiffusionModel(Model):
        """ Three-dimensional diffusion model. This includes the anamalous diffusion
            exponent alpha, which can be set to 1 for normal diffusion. """
        params = [
                Parameter('tau_d',      'Diffusion time constant', def_scope='fitted'),
                Parameter('a',          'Aspect ratio', def_value=3, def_scope='fitted'),
                Parameter('n',          'Concentration', def_scope='fitted'),
                Parameter('alpha',      'Anamalous diffusion exponent (1=normal diffusion)', def_value=1, def_scope='fixed'),
        ]

        def compute_G(self, p, x):
                a = p['a']
                n = p['n']
                tau_taud = (x / p['tau_d'])**p['alpha']

                b = 1. / (1. + tau_taud)
                c = 1. / (1. + tau_taud * a**-2)
                return (1. / n) * b * sqrt(c)

@register_model('3d_diff_triplet')
class NormalDiffusionTripletModel(Model):
        """ Three-dimensional diffusion model with triplet correction """
        params = [
                Parameter('tau_d',      'Diffusion time constants', def_scope='fitted'),
                Parameter('tau_F',      'Triplet state relaxation time', def_scope='fitted'),
                Parameter('a',          'Aspect ratio', def_value=3, def_scope='fitted'),
                Parameter('n',          'Concentration', def_scope='fitted'),
                Parameter('F',          'Fraction of particles in triplet state'),
        ]

        def compute_G(self, p, x):
                a = p['a']
                F = p['F']
                n = p['n']
                tau_taud = x / p['tau_d']
                tau_tauF = x / p['tau_F']

                b = 1. / (1. + tau_taud)
                c = 1. / (1. + tau_taud * a**-2)
                d = (1. - F + F * exp(-tau_tauF)) / (1. - F)
                return d * b * sqrt(c) / n

def load_favia(file):
        dt = [('lag','f'), ('G','f'), ('var','f')]
        d = numpy.genfromtxt(file, dtype=dt, usecols=(0,3,4))
        d['G'] -= 1.0   # Subtract out offset
        return d

def plot_model(ax, model, curve_names, npts=1e3):
        for curve,name in zip(model.curves, curve_names):
                x = linspace(min(curve['lag']), max(curve['lag']), npts)
                m = model.G(curve, x)
                ax.semilogx(x, m, label='%s (fit)' % name)
                # TODO: Add parameters to plot

import cmd
class ParamConfig(cmd.Cmd):
        def __init__(self, params):
                self.params = params
                cmd.Cmd.__init__(self)

        def do_scope(self, line):
                """ Sets the scope of a parameter """
                name, scope = line.split()
                name = name.strip()
                if name not in self.params:
                        print 'Invalid parameter %s' % name
                        return
                if scope not in ['fitted', 'fixed']:
                        print 'Invalid scope %s' % scope
                        return
                self.params[name].scope = scope
                
        def do_initial(self, line):
                """ Sets the initial value of a parameter """
                name, value = line.split()
                name = name.strip()
                if name not in self.params:
                        print 'Invalid parameter %s' % name
                        return
                try:
                        a = value.split(',')
                        if len(a) == 1:
                                self.params[name].value = suffix_parse.parse(value)
                        elif len(a) == len(params.curves):
                                self.params[name].value = [suffix_parse.parse(v) for v in a]
                        else:
                                print 'Not enough values (expected %d)' % len(params.curves)
                except:
                        print 'Invalid value %s' % value
                        pass

        def do_done(self, line):
                """ Finished editing parameters """
                return True

        def do_help(self, line):
                """ Help """
                print """
Commands:
============
scope [param] fixed|fitted
    Set the scope of a parameter
initial [param] [value]
    Set the initial value of a parameter
done
    Stop modifying parameters
"""

        def postcmd(self, stop, line):
                print 'Parameters:'
                print_parameters(self.params)
                return stop

        def preloop(self):
                print 'Parameters:'
                print_parameters(self.params)

def print_parameters(params):
        for p in params.values():
                v = suffix_parse.format(p.value) if p.value is not None else 'not set'
                print '%15s  (%6s)   =   %s' % (p.name, p.scope, v)

def print_models():
        print 'Known models:'
        for k,m in models.items():
                print '  %s : %s' % (k, m.__doc__)
                print '     Parameters:'
                print '          name\tdefault scope\tdefault value\tdescription'
                for p in m.params:
                        print '    %10s\t%13s\t%13s\t%s' % (p.name, p.def_scope, p.def_value, p.description)
                print

if __name__ == '__main__':
        import argparse
        parser = argparse.ArgumentParser()
        parser.add_argument('-e', '--early-cutoff', metavar='LAG', default=0,
                            help='Early lag cutoff time')
        parser.add_argument('-n', '--no-fit', action='store_true',
                            help="Don't attempt to fit data; to be used with --plot")
        parser.add_argument('-p', '--plot', action='store_true',
                            help='Produce plot of data and fits')
        parser.add_argument('-o', '--output', metavar='FILE',
                            help='Save plot to FILE')
        parser.add_argument('-m', '--model', metavar='MODEL', required=True,
                            help='Specify a fit function to use (options: %s)' % ', '.join(models.keys()))
        parser.add_argument('-s', '--set', metavar='SCOPE:PARAM=VALUE', action='append', dest='params',
                            help='Set an initial fit parameter')
        parser.add_argument('-f', '--file', metavar='FILE', dest='params_file',
                            help='Specify parameters file for initial fit parameters')
        parser.add_argument('curves', metavar='FILE', nargs='+', type=argparse.FileType('r'),
                            help='Correlation functions to plot')
        args = parser.parse_args()

        data = []
        for f in args.curves:
                datum = load_favia(f)
                take = datum['lag'] > args.early_cutoff
                data.append(datum[take])

        if args.model == 'help':
                print_models()
                sys.exit(0)
        elif args.model not in models:
                parser.error('Error: Unknown fitting model "%s"' % args.model)

        model = models[args.model]()
        params = Parameters(model, data)
        print 'Fitting %d curves against model %s' % (len(data), args.model)

        if args.params_file is not None:
                # TODO
                pass

        # Load parameters from arguments
        if args.params is not None:
                for s in args.params:
                        scope,pv = s.split(':')
                        p,v = pv.split('=')
                        if scope not in ['fitted', 'fixed']:
                                parser.error('Invalid scope %s' % scope)
                        if p not in params:
                                parser.error('Unknown parameters %s' % p)

                        v = suffix_parse.parse(v)
                        params[p].scope = scope
                        params[p].value = v

        # Start prompt
        c = ParamConfig(params)
        c.cmdloop()

        print 'Initial Parameters:'
        print_parameters(params)

        new, chi_squared = fit(data, model, params)
        print 'Chi^2 = %e' % chi_squared
        print 'Fitted Parameters:'
        print_parameters(new)

        # Plot
        if args.plot:
                from matplotlib.figure import Figure
                fig = Figure()
                if args.output:
                        from matplotlib.backends.backend_agg import FigureCanvasAgg as FigureCanvas
                        canvas = FigureCanvas(fig)
                        fig.savefig(args.output)

                ax = fig.add_subplot(111)
                ax.set_xlabel(r'$\tau$')
                ax.set_ylabel(r'$G$')
                ax.legend()
                ax.autoscale_view(tight=True, scalex=True)
                
                for curve,name in zip(data, args.curves):
                        ax.semilogx(curve['lag'], curve['G'], label=name,
                                    linestyle='None', marker='+')

                if not args.no_fit:
                        from mpl_toolkits.axes_grid1 import make_axes_locatable
                        divider = make_axes_locatable(ax)
                        plot_model(fig, model)

                print 'saved to', args.output
                if args.output:
                        fig.savefig(args.output)
                else:
                        fig.show()
                
