#!/usr/bin/python
# vim: set fileencoding=utf-8

# fcs-tools - Tools for FCS data analysis
#
# Copyright Â© 2010 Ben Gamari
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see http://www.gnu.org/licenses/ .
#
# Author: Ben Gamari <bgamari@physics.umass.edu>
#

import sys 
from collections import namedtuple

import numpy as np
import scipy
from scipy.optimize import leastsq
from numpy import min, max, mean, exp, power, sqrt, log10, sum
import suffix_parse

"""
fcs-fit: Multiple-curve non-linear regression framework for fitting of FCS
correlation functions

This is a framework for "global" analysis of FCS correlation functions.
"""

models = {}
def register_model(*names):
        def reg(cls):
                if not issubclass(cls, Model):
                        raise Exception("Registering model that doesn't inherit from model")
                for n in names:
                        models[n] = cls
                return cls
        return reg

class Parameter(object):
        def __init__(self, name, description, def_value=None, def_scope=None):
                self.name = name
                self.description = description
                self.def_value = def_value
                self.def_scope = def_scope

class Parameters(dict):
        def __init__(self, model, curves):
                from copy import copy
                assert(len(curves) > 0)
                self.curves = curves
                
                for p in model.params:
                        a = copy(p)
                        a.scope = p.def_scope
                        a.value = p.def_value
                        self[p.name] = a

        def validate(self):
                """ Needs to be called before pack or unpack are used """
                self._fitted = []
                self._fixed = []
                for p in self.values():
                        if p.scope == 'fitted':
                                self._fitted.append(p.name)
                        elif p.scope == 'fixed':
                                self._fixed.append(p.name)
                        else:
                                raise RuntimeError('Invalid scope')

        def _unpack(self, packed):
                """ Unpack parameters from vector from leastsq """
                n = len(self.curves)
                i = 0
                for k in self._fitted:
                        if isinstance(self[k], list):
                                self[k].value = packed[i:i+n]
                                i += n
                        else:
                                self[k].value = packed[i]
                                i += 1

        def _pack(self):
                """ Pack fitted parameters into vector for leastsq """
                packed = []
                for k in self._fitted:
                        if isinstance(self[k].value, list):
                                packed.extend(self[k].value)
                        else:
                                packed.append(self[k].value)
                return np.array(packed)

        def _curve_params(self, curve):
                """ Generate full parameters dict from fixed and fitted parameters """
                params = {}
                for k in self:
                        v = self[k].value
                        params[k] = v[i] if isinstance(v, list) else v
                return params

class Model(object):
        """
        Represents a fitting model for a multi-curve non-linear regression
 
        A model has parameters, which can be either fixed or chosen for
        optimization. In the latter case, the parameter can be taken as
        determined by the fit, or fixed per-curve. In either case, the parameter
        can be set independently for each curve, or homogenous across all
        curves. Each parameter is set to be fixed/fitted and (in)homogenous at
        model creation.

        To implement a new fit function, one must inherit from the Model class,
        providing a class member 'params' list giving the parameters supported by
        the model and their default scope. The fit function itself is given by
        the compute_G function.
        """

        # Override this in subclasses
        params = []

        @classmethod
        def param(cls, name):
                for p in cls.params:
                        if p.name == name: return p
                
        def compute_G(self, params, x):
                """ Compute the value of the fit function with the given
                    parameters on the given domain """
                pass

def _compute_error(p, curves, params, model):
        err = []
        params._unpack(p)
        for i,c in enumerate(curves):
                cparams = params._curve_params(i)
                G = model.compute_G(cparams, c['lag'])
                #err.extend(c['G'] - G)
                err.extend((c['G'] - G) / c['var']**2)

        err = np.array(err)
        return err

def fit(curves, model, params):
        """ Run the regression. Returns a new Model object with optimized
            parameters. One can then evaluate the optimized fit
            functions using this new object's G function. """
        from copy import deepcopy
        params = deepcopy(params)
        params.validate()
        p0 = params._pack()
        # Not sure why epsfcn needs to be changed
        res = scipy.optimize.leastsq(_compute_error, p0, args=(curves, params, model), full_output=True, epsfcn=1e-7)
        p, cov_x, infodict, mesg, ier = res
        print cov_x, mesg
        #if cov_x is None: raise RuntimeError('Fit failed to converge (flat axis)')
        params._unpack(p)
        return params

@register_model('3d_diff')
class DiffusionModel(Model):
        """ Three-dimensional diffusion model. This includes the anamalous diffusion
            exponent alpha, which can be set to 1 for normal diffusion. """
        params = [
                Parameter('tau_d',      'Diffusion time (microseconds)', def_scope='fitted'),
                Parameter('a',          'Aspect ratio', def_value=3, def_scope='fitted'),
                Parameter('n',          'Concentration', def_scope='fitted'),
                Parameter('alpha',      'Anamalous diffusion exponent (1=normal diffusion)', def_value=1, def_scope='fixed'),
                Parameter('offset',     'Offset', def_value=0, def_scope='fixed'),
        ]

        def compute_G(self, p, x):
                a = p['a']
                n = p['n']
                tau_taud = (x / (p['tau_d']*1e-6))**p['alpha']

                b = 1. / (1. + tau_taud)
                c = 1. / (1. + tau_taud * a**-2)
                return (1. / n) * b * sqrt(c) + p['offset']

@register_model('3d_diff_triplet')
class NormalDiffusionTripletModel(Model):
        """ Three-dimensional diffusion model with triplet correction """
        params = [
                Parameter('tau_d',      'Diffusion time constants', def_scope='fitted'),
                Parameter('tau_F',      'Triplet state relaxation time', def_scope='fitted'),
                Parameter('a',          'Aspect ratio', def_value=3, def_scope='fitted'),
                Parameter('n',          'Concentration', def_scope='fitted'),
                Parameter('F',          'Fraction of particles in triplet state'),
        ]

        def compute_G(self, p, x):
                a = p['a']
                F = p['F']
                n = p['n']
                tau_taud = x / p['tau_d']
                tau_tauF = x / p['tau_F']

                b = 1. / (1. + tau_taud)
                c = 1. / (1. + tau_taud * a**-2)
                d = (1. - F + F * exp(-tau_tauF)) / (1. - F)
                return d * b * sqrt(c) / n

def load_favia(file):
        dt = [('lag','f'), ('G','f'), ('var','f')]
        d = np.genfromtxt(file, dtype=dt, usecols=(0,3,4))
        d['G'] -= 1.0   # Subtract out offset
        return d

def plot_model(fig, ax, params, model, curve_names, npts=1e3):
        from mpl_toolkits.axes_grid1 import make_axes_locatable
        divider = make_axes_locatable(ax)
        for i,curve in enumerate(params.curves):
                name = curve_names[i].name
                start = log10(min(curve['lag']))
                stop = log10(max(curve['lag']))
                x = np.logspace(start, stop, npts)
                cparams = params._curve_params(i)
                m = model.compute_G(cparams, x)
                ax.semilogx(x, m, label='%s (fit)' % name)

                ax2 = divider.append_axes('top', size=1.2, pad=0.1, sharex=ax)
                ax2.axhline(y=0, linewidth=1, color='k', alpha=0.5)
                d = params.curves[i]
                ax2.semilogx(d['lag'], model.compute_G(cparams, d['lag']) - d['G'])
                for t in ax2.get_xticklabels():
                        t.set_visible(False)

                text = 'chi^2             = %1.1e' % chi_sq
                text += '\nchi^2/DOF         = %1.1e' % (chi_sq / len(curves[i])-len(params))
                ptext = ["%3s  %-12s = %1.3e" % (p.scope[0:3], p.name, p.value)
                                for p in params.values() if isinstance(p.value, list)]
                text += '\n' + '\n'.join(sorted(ptext))
                ax2.text(1.05, 0.90, name,
                                weight='bold',
                                fontsize=12,
                                horizontalalignment='left',
                                verticalalignment='top',
                                transform=ax2.transAxes)
                ax2.text(1.07, 0.77, text,
                                fontsize=8,
                                family='monospace',
                                horizontalalignment='left',
                                verticalalignment='top',
                                transform=ax2.transAxes)

        ptext = ["%3s  %-12s = %1.3e" % (p.scope[0:3], p.name, p.value)
                        for p in params.values() if not isinstance(p.value, list)]
        text = '\n' + '\n'.join(sorted(ptext))
        ax.text(1.05, 0.95, 'Global Parameters',
                        weight='bold',
                        fontsize=12,
                        horizontalalignment='left',
                        verticalalignment='top',
                        transform=ax.transAxes)
        ax.text(1.07, 0.90, text,
                        fontsize=8,
                        family='monospace',
                        horizontalalignment='left',
                        verticalalignment='top',
                        transform=ax.transAxes)

def parse_param_value(value):
        a = value.split(',')
        if len(a) == 1:
                return suffix_parse.parse(value)
        elif len(a) == len(params.curves):
                return [suffix_parse.parse(v) for v in a]
        else:
                raise RuntimeError('Not enough values (expected %d)' % len(params.curves))

import cmd
class ParamEditor(cmd.Cmd):
        def __init__(self, params):
                self.params = params
                cmd.Cmd.__init__(self)

        def do_scope(self, line):
                """ Sets the scope of a parameter """
                name, scope = line.split()
                name = name.strip()
                if name not in self.params:
                        print 'Invalid parameter %s' % name
                        return
                if scope not in ['fitted', 'fixed']:
                        print 'Invalid scope %s' % scope
                        return
                self.params[name].scope = scope
                
        def do_initial(self, line):
                """ Sets the initial value of a parameter """
                name, value = line.split()
                name = name.strip()
                if name not in self.params:
                        print 'Invalid parameter %s' % name
                        return
                try:
                        self.params[name].value = parse_param_value(value)
                except:
                        print 'Invalid value %s' % value

        def do_done(self, line):
                """ Finished editing parameters """
                return True

        def do_help(self, line):
                """ Help """
                print """
Commands:
============
scope [param] fixed|fitted
    Set the scope of a parameter
initial [param] [value]
    Set the initial value of a parameter
done
    Stop modifying parameters
"""

        def postcmd(self, stop, line):
                print 'Parameters:'
                print_parameters(self.params)
                return stop

        def preloop(self):
                print 'Parameters:'
                print_parameters(self.params)

def print_parameters(params):
        for p in params.values():
                v = suffix_parse.format(p.value) if p.value is not None else 'not set'
                print '%15s  (%6s)   =   %s' % (p.name, p.scope, v)

def print_models():
        print 'Known models:'
        for k,m in models.items():
                print '  %s : %s' % (k, m.__doc__)
                print '     Parameters:'
                print '          name\tdefault scope\tdefault value\tdescription'
                for p in m.params:
                        print '    %10s\t%13s\t%13s\t%s' % (p.name, p.def_scope, p.def_value, p.description)
                print

if __name__ == '__main__':
        import argparse
        parser = argparse.ArgumentParser()
        parser.add_argument('-e', '--early-cutoff', metavar='LAG', default=0,
                            help='Early lag cutoff time')
        parser.add_argument('-n', '--no-fit', action='store_true',
                            help="Don't attempt to fit data; to be used with --plot")
        parser.add_argument('-p', '--plot', action='store_true',
                            help='Produce plot of data and fits')
        parser.add_argument('-o', '--output', metavar='FILE',
                            help='Save plot to FILE')
        parser.add_argument('-m', '--model', metavar='MODEL', required=True,
                            help='Specify a fit function to use (options: %s)' % ', '.join(models.keys()))
        parser.add_argument('-E', '--edit',
                            help='Start command-line parameters editor')
        parser.add_argument('-s', '--set', metavar='SCOPE:PARAM=VALUE', action='append', dest='params',
                            help='Set an initial fit parameter')
        parser.add_argument('-f', '--file', metavar='FILE', dest='params_file',
                            help='Specify parameters file for initial fit parameters')
        parser.add_argument('curves', metavar='FILE', nargs='+', type=argparse.FileType('r'),
                            help='Correlation functions to plot')
        args = parser.parse_args()

        curves = []
        for f in args.curves:
                datum = load_favia(f)
                taken = datum[datum['lag'] > args.early_cutoff]
                curves.append(taken)

        if args.model == 'help':
                print_models()
                sys.exit(0)
        elif args.model not in models:
                parser.error('Error: Unknown fitting model "%s"' % args.model)

        model = models[args.model]()
        params = Parameters(model, curves)
        print 'Fitting %d curves against model %s' % (len(curves), args.model)

        if args.params_file is not None:
                # TODO
                pass

        # Parse parameters from arguments
        if args.params is not None:
                for s in args.params:
                        scope,pv = s.split(':')
                        p,v = pv.split('=')
                        if scope not in ['fitted', 'fixed']:
                                parser.error('Invalid scope %s' % scope)
                        if p not in params:
                                parser.error('Unknown parameters %s' % p)
                        params[p].scope = scope
                        params[p].value = parse_param_value(v)

        if args.edit:
                c = ParamEditor(params)
                c.cmdloop()

        print 'Initial Parameters:'
        print_parameters(params)

        new = fit(curves, model, params)
        print 'Parameters:'
        print_parameters(new)
        for i,c in enumerate(curves):
                d = params.curves[i]
                err = model.compute_G(params._curve_params(i), d['lag']) - d['G']
                chi_sq = sum(err**2)
                print args.curves[i].name
                print 'Chi^2 = %e' % chi_sq
                print 'Chi^2 / DOF = %f' % (chi_sq / (len(curves[i])-len(params)))

        # Plot
        if args.plot:
                from matplotlib.figure import Figure
                fig = Figure()
                if args.output:
                        from matplotlib.backends.backend_agg import FigureCanvasAgg as FigureCanvas
                        canvas = FigureCanvas(fig)
                        fig.savefig(args.output)

                ax = fig.add_subplot(111)
                
                for curve,name in zip(curves, args.curves):
                        ax.semilogx(curve['lag'], curve['G'], label=name.name,
                                    linestyle='None', marker='+')

                if not args.no_fit:
                        fig.subplots_adjust(right=0.7, left=0.1)
                        plot_model(fig, ax, new, model, args.curves)

                ax.set_xlabel(r'$\tau$')
                ax.set_ylabel(r'$G$')
                ax.autoscale_view(tight=True, scalex=True)
                leg = ax.legend()
                for t in leg.get_texts():
                        t.set_fontsize('small')

                print 'saved to', args.output
                if args.output:
                        fig.savefig(args.output)
                else:
                        fig.show()
                
