#!/usr/bin/python

import argparse
from argparse import ArgumentParser

import os.path
from photon_tools.favia import corr
from photon_tools.read_photons import TimestampFile

import numpy as np
from matplotlib import pyplot as pl
import math

verbose = False

def split_chunks(x, n):
    l = len(x) / n
    return [ x[i*l:(i+1)*l] - x[i*l] for i in range(n) ]

def correlate_multi(x, y, n=10, **kwargs):
    x_chunks = split_chunks(x, n)
    y_chunks = split_chunks(y, n)
    corrs = np.vstack( corr(xc, yc, **kwargs) for (xc,yc) in zip(x_chunks,y_chunks) )
    # TODO: find source of offset when using favia to compute full correlation function
    #g = corr(x, y, **kwargs)['G']
    g = np.mean(corrs['G'], axis=0)
    var = np.var(corrs['G'], axis=0) / (n-1)
    return (np.rec.fromarrays([corrs[0]['lag'], g, var], names='lag,G,var'), corrs['G'])
    
def plot_corr(corrs, output=None):
    pl.clf()
    pl.xscale('log')
    for corr in corrs:
        pl.errorbar(corr['lag'], corr['G'], yerr=np.sqrt(corr['var']), fmt='.')
    pl.axhline(1, color='0.7')
    pl.xlabel('Lag (s)')
    pl.ylabel('Correlation')
    if output is not None:
        pl.savefig(output)
    
parser = ArgumentParser(description='Compute and plot correlation functions of photon timestamps',
                        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
parser.add_argument('files', metavar='FILE', type=argparse.FileType('r'), nargs='+',
                    help='Input timestamp files')
parser.add_argument('-a', '--a-channel', type=int, default=0,
                    help='Channel to run correlate')
parser.add_argument('-b', '--b-channel', type=int, default=1,
                    help='Channel to run correlate')
parser.add_argument('-E', '--min-lag', type=float, default=1e-7,
                    help='Smallest lag to compute')
parser.add_argument('-L', '--max-lag', type=float, default=1,
                    help='Longest lag to compute')
parser.add_argument('-n', '--nchunks', type=int, default=10,
                    help='Number of chunks to split data into for variance computation')
parser.add_argument('--chunks', action='store_true', help='Produce file containing chunks')
parser.add_argument('--plot-chunks', action='store_true', help='Produce plot showing correlation of each chunk')
parser.add_argument('-f', '--fineness', type=int, default=8,
                    help='Number of lags per octave')
parser.add_argument('-v', '--verbose', action='store_true',
                    help='Produce debugging output')
parser.add_argument('-l', '--label', type=str, default='corr',
                    help='Descriptive label for dataset shown in plot')
parser.add_argument('-j', '--jiffy', type=float, default=None,
                    help='Acquisition timebase period')
parser.add_argument('-s', '--single', action='store_true',
                    help="Produce only cross-correlations of given channels, skipping auto-correlations")
parser.add_argument('-p', '--plot', action='store_true',
                    help='Plot each computed correlation function')
parser.add_argument('-O', '--output-type', default='png',
                    help='File format of plot output')
parser.add_argument('-t', '--start-time', default=None, type=float,
                    help='Start time of usable data (seconds)')
parser.add_argument('-T', '--stop-time', default=None, type=float,
                    help='Stop time of usable data (seconds)')
args = parser.parse_args()
verbose = args.verbose

correlations = [(args.a_channel, args.a_channel, 'acorr-%d' % args.a_channel),
                (args.b_channel, args.b_channel, 'acorr-%d' % args.b_channel),
                (args.a_channel, args.b_channel, 'xcorr-%d-%d' % (args.a_channel, args.b_channel))
               ]
if args.single:
    correlations = [(args.a_channel, args.b_channel, args.label)]

for file in args.files:
    for (ac,bc,label) in correlations:
        fname = os.path.basename(file.name)
        a = TimestampFile(file.name, ac)
        b = TimestampFile(file.name, bc)
        if len(a.data) == 0 or len(b.data) == 0:
            print "No data in one channel, skipping"
            continue

        jiffy = a.jiffy
        if args.jiffy is not None:
            jiffy = args.jiffy
        if jiffy is None:
            jiffy = 1. / 128e6
            print "Couldn't identify jiffy of file. Defaulting to %e s" % jiffy

        ad,bd = a.data, b.data
        t0 = min(ad[0], bd[0])
        if args.start_time is not None:
            ad = ad[ad - t0 >= args.start_time / jiffy]
            bd = bd[bd - t0 >= args.start_time / jiffy]
        if args.stop_time is not None:
            ad = ad[ad - t0 < args.stop_time / jiffy]
            bd = bd[bd - t0 < args.stop_time / jiffy]

        print label
        print '  %20s, channel %d: %d events (%d after filtering)' % \
              (fname, bc, len(a.data), len(ad))
        print '  %20s, channel %d: %d events (%d after filtering)' % \
              (fname, ac, len(b.data), len(bd))
        
        kwargs = {
            'jiffy': jiffy,
            'short_grain': args.min_lag,
            'long_lag': args.max_lag,
            'fineness': args.fineness,
            'verbose': args.verbose
        }

        c = None
        if args.nchunks > 1:
            c,chunks = correlate_multi(ad, bd, n=args.nchunks, **kwargs)
            if args.chunks:
                np.savetxt(fname+'.chunks.'+label, np.vstack([c['lag'], chunks]).T)
            if args.plot_chunks:
                plot_corr([np.rec.fromarrays([c['lag'],chunks[i,:],np.zeros(c.shape)],
                                             names='lag,G,var')
                           for i in range(chunks.shape[0])],
                          fname+'.'+label+'.chunks.'+args.output_type)
        else:
            c = corr(ad, bd, **kwargs)

        print '  G(%1.2e s) = %1.3f' % (c[0]['lag'], c[0]['G'])
        print '  G(%1.2e s) = %1.3f' % (c[-1]['lag'], c[-1]['G'])
        print

        with open(fname+'.'+label, 'w') as f:
                f.write('# lag            G(tau)            variance\n')
                np.savetxt(f, c)

        if args.plot:
            plot_corr([c], fname+'.'+label+'.'+args.output_type)

