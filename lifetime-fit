#!/usr/bin/python

from __future__ import division
import sys

import lmfit
import numpy as np
from numpy import sum, newaxis, sqrt
import scipy.signal, scipy.optimize
from matplotlib import pyplot as pl

from argparse import ArgumentParser

parser = ArgumentParser()
parser.add_argument('corr', metavar='FILE',
                    help="correlation function")
parser.add_argument('--irf', '-i', metavar='FILE',
                    help='instrument response function')
parser.add_argument('--components', '-c', type=int, default=1,
                    help='number of fit components')
parser.add_argument('--rep-rate', '-r', type=float, default=80e6,
                    help='pulse repetition rate (Hertz)')
parser.add_argument('--periods', '-p', type=int, default=1,
                    help='how many pulse periods we should fit to')
parser.add_argument('--output', '-o', type=str,
                    help='where to send output')
parser.add_argument('--no-offset', action='store_true',
                    help='do not fit temporal offset between data and IRF')
args = parser.parse_args()

# Various parameters
rep_rate = args.rep_rate
window = args.periods

log_file = sys.stdout
if args.output is not None:
    log_file = open(args.output, 'w')

def log(s):
    log_file.write(s + '\n')

log('%s with IRF from %s' % (args.corr, args.irf))

irf = np.genfromtxt(args.irf)
jiffy = (irf[1,0] - irf[0,0]) * 1e-12
per = int(1 / rep_rate / jiffy)
n = int(window / rep_rate / jiffy)
irf = irf[:n,1]

corr = np.genfromtxt(args.corr)[:n,1]
# Ensure we have no zero counts
#corr = corr[corr > 0]
corr_norm = np.sum(corr)
corr /= corr_norm

# Subtract background from and normalize IRF
log('IRF background = %1.2f' % np.median(irf))

times = np.arange(corr.shape[0])

from lmfit.models import ExponentialModel, ExponentialGaussianModel, ConstantModel
from lmfit import Parameters

def shifted_exponential(x, amplitude=1, decay=1, shift=0):
    ret = amplitude * np.exp(-(x + shift) / decay)
    ret[x < shift] = 0
    return ret

class ShiftedExponentialModel(lmfit.Model):
    def __init__(self, *args, **kwargs):
        super(ShiftedExponentialModel, self).__init__(shifted_exponential, *args, **kwargs)

fit_irf = False
if fit_irf:
    irf_model = ExponentialGaussianModel() + ShiftedExponentialModel(prefix='d_')
    model = irf_model + ConstantModel(prefix='bg_')
    pars = model.make_params(center=261, amplitude=2000, bg_c=4,
                             d_shift=400, d_decay=50, d_amplitude=200)
    ts = np.arange(len(irf))
    fit = model.fit(irf, pars, x=ts)
    print pars
    print fit.fit_report()
    pl.plot(ts, irf)
    pl.plot(ts, fit.best_fit)
    pl.yscale('log')
    pl.show()

from convolve_model import ConvolveModel
def irf_model(irf, period, decay, decay_model, offset=0):
    ts = np.arange(len(irf))
    n_periods = 2*(ts.shape[0] // period + 1)
    irf_normed = irf / sum(irf)
    shift = ts.shape[0] % per
    periodic_irf = np.roll(np.hstack(n_periods*[irf_normed[:period]]),
                           shift + offset)
    print periodic_irf.shape
    return ConvolveModel(periodic_irf, decay_model)

shifts = {}
for shift in range(-20, 20):
    decay_model = sum([lmfit.models.ExponentialModel(prefix='c%d_' % i)
                       for i in range(1)])
    background = ConstantModel(prefix='bg_')
    model = irf_model(irf, per, corr, decay_model, offset=shift) + background
    pars = model.make_params(c0_decay=2000, c0_amplitude=3000,
                             bg_c=np.median(corr))

    ts = np.arange(len(corr))
    fit = model.fit(corr, pars, x=ts, weights=1/corr)
    shifts[shift] = fit

shift,fit = min(shifts.items(), key=lambda (k,v): v.chisqr)
print 'shift', shift
print fit.fit_report()
log(fit.fit_report())

pl.suptitle('%s with IRF from %s\nreduced $\\chi^2 = %1.2f$' % (args.corr, args.irf, fit.redchi))
pl.plot(ts, corr, label='signal')
pl.plot(ts, fit.best_fit, label='ffit')
pl.yscale('log')
pl.legend(loc='lower right')
pl.xlabel('lag (ns)')
pl.ylabel('counts')
pl.show()
pl.savefig('%s.svg' % args.corr)
